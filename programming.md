# Программирование

- [Принципы ООП](#принципы-ооп)
- [Типизация, виды типизации](#типизация-виды-типизации)
- [SOLID](#solid)
    - [Single responsibility principle (SRP)](#single-responsibility-principle-srp)
    - [Open-closed principle (OCP)](#open-closed-principle-ocp)
    - [Liskov substitution principle (LSP)](#liskov-substitution-principle-lsp)
    - [Interface segregation principle (ISP)](#interface-segregation-principle-isp)
    - [Dependency inversion principle (DIP)](#dependency-inversion-principle-dip)
- [GRASP](#grasp)
    - [Information expert](#information-expert)
    - [Creator](#creator)
    - [Controller](#controller)
    - [Low coupling](#low-coupling)
    - [High cohesion](#high-cohesion)
    - [Polymorphism](#polymorphism)
    - [Pure fabrication](#pure-fabrication)
    - [Indirection](#indirection)
    - [Protected variations](#protected-variations)
- [DRY](#dry)
- [KISS](#kiss)
- [YAGNI](#yagni)
- [Law of Demeter](#law-of-demeter)
- [Coupling](#coupling)
- [Инварианты](#инварианты)
- [Рефакторинг](#рефакторинг)

## Принципы ООП

### Инкапсуляция

Инкапсуляция — механизм, позволяющий связывать данные и методы для работы с этими данными в единый механизм. Позволяет скрывать детали реализации при помощи модификаторов доступа. Инкапсуляция и сокрытие данных — не одно и то же.

### Полиморфизм

Один интерфейс, множество реализаций. Объекты с одинаковой спецификацией могут иметь разные реализации. Полиморфизм в языках программирования и теории типов — способность функции обрабатывать данные разных типов. Виды полиморфизма — параметрический, ad-hoc и полиморфизм подтипов.

### Наследование

Наследование — создание нового класса на основе уже существующего. Наследник включает в себя все свойства и методы родителя. С объектами наследника можно обращаться точно так же, как с объектами базового класса.

### Абстракция

Абстракция — набор значимых характеристик объекта. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

## Типизация, виды типизации

Существует два вида типизации — **статическая** (типы проверяются на этапе компиляции) и **динамическая** (типы проверяются в рантайме).

Типизация может быть **сильной** (строгой) и **слабой**, в разных ЯП "сила" типизации разная. Например, в JS слабая типизация, в PHP средняя, в Python ближе к сильной.

**Утиная типизация** — определение факта реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов.

## SOLID

Основной смысл — стремление уменьшить эффект каскадного изменения модулей.

### Single responsibility principle (SRP)

На каждый класс должна быть возложена одна единственная обязанность. Классы должны иметь одну и только одну причину для изменений.

### Open-closed principle (OCP)

Классы должны быть открыты для расширения, но закрыты для изменения. Т.е. классы могут менять свое поведение без изменения их исходного кода.

### Liskov substitution principle (LSP)

Классы, которые используют базовый класс, должны иметь возможность использовать наследников базового класса не зная об этом.

### Interface segregation principle (ISP)

Клиенты не должны зависеть от методов, которые они не используют. Слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

### Dependency inversion principle (DIP)

Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

## GRASP

GRASP — тот же SOLID, но другими словами. Если плохо воспринимается SOLID — стоит посмотреть GRASP.

### Information expert

Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.

### Creator

Класс должен создавать экземпляры тех классов, которые он может содержать или агрегировать, записывать, использовать и инициализировать, имея нужные данные.

### Controller

Отвечает за операции, запросы на которые приходят от пользователя. Не выполняет работу самостоятельно, а делегирует компетентным исполнителям.

### Low coupling

Слабое зацепление — распределение ответственностей и данных, обеспечивающее взаимную независимость классов. Класс со "слабым" зацеплением:

- имеет слабую зависимость от других классов
- не зависит от внешних изменений (изменение в одном классе оказывает слабое влияние на другие классы)
- прост для повторного использования

> Нужно больше информации, дополнить.

### High cohesion

Высокая связность. По сути это single responsibility принцип.

### Polymorphism

> Нужно наполнить.

### Pure fabrication

Существует понятие модели программирования по предметной области, согласно которой, каждой сущности из предметной области соответствует один или более классов программной среды. При этом, обязанности взаимодействия сущностей, как правило накладываются на них самих. Такой подход имеет очевидный недостаток — высокая связность модулей системы. Шаблон чистая выдумка позволяет решить данную проблему, путем введения в программную среду дополнительного класса (не отражающего реальной сущности из предметной области) и наделение его требуемыми обязанностями.

Например, обязанности по сохранению информации о клиентах судоходной компании можно назначить выдуманному классу **ClientsSaver**.

Применение шаблона чистая выдумка позволяет дизайну системы соответствовать принципам низкой связности и высокого зацепления.

### Indirection

> Нужно наполнить.

### Protected variations

> Нужно наполнить.

## DRY

Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы.

Нарушения принципа DRY называют WET — "write everything twice" (пиши всё по два раза) или "we enjoy typing" (нам нравится печатать).

## KISS

Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

## YAGNI

Отказ от добавления функциональности, в которой нет непосредственной надобности.

## Law of Demeter

Говоря упрощённо, каждый программный модуль:

- должен обладать ограниченным знанием о других модулях — знать о модулях, которые имеют непосредственное отношение к этому модулю
- должен взаимодействовать только с известными ему модулями "друзьями", не взаимодействовать с "незнакомцами"
- обращаться только к непосредственным "друзьям"

## Coupling

"Плохие" виды связанности:

- content — ?
- global — глобальные переменные, база данных
- condition — ?
- temporal — завязанность на времени, например, методы нужно вызывать в определенной последовательности

Эти получше:

- data — ?
- message — когда у методов нет аргументов, т.е. объекты обмениваются сообщениями

От data и message связанностей не получится избавиться. Нужно стараться переходить от "плохих" видов связанности к лучшим.

## Инварианты

В коде они обычно выглядят так:

- транзакции — какие то изменения, которые либо прошли целиком, либо целиком откатились
- валидация перед сохранением — которая либо дала сохранить изменения, либо упала с ошибкой о некорректном состоянии
- в целом, любое исключение может оказаться следствием поддержки инварианта — обеспечение целостности
- функциональные программы часто инвариантны, т.к. не меняют состояние исходного объекта
- приватные поля объекта, которые может менять только сам объект, плюс каждый публичный метод меняет их из рабочего и согласованного состояния в рабочее и согласованное состояние

## Рефакторинг

При анализе большинства программ обнаруживается, что большая часть времени расходуется небольшой частью кода. Если в равной мере оптимизировать весь код, то окажется, что 90% оптимизации произведено впустую.

Вместо реализации гибких решений следует задаться вопросом — "насколько сложно будет с помощью рефакторинга преобразовать обычное решение в гибкое?". Если, как чаще всего случается, ответ будет "весьма несложно", то надо просто реализовать обычное решение.
