# Программирование

- [Принципы ООП](#принципы-ооп)
    - [Обмен сообщениями](#обмен-сообщениями) 
    - [Инкапсуляция](#инкапсуляция)
    - [Полиморфизм](#полиморфизм)
    - [Наследование](#наследование)
    - [Абстракция](#абстракция)
- [SOLID](#solid)
    - [Single responsibility principle (SRP)](#single-responsibility-principle-srp)
    - [Open-closed principle (OCP)](#open-closed-principle-ocp)
    - [Liskov substitution principle (LSP)](#liskov-substitution-principle-lsp)
    - [Interface segregation principle (ISP)](#interface-segregation-principle-isp)
    - [Dependency inversion principle (DIP)](#dependency-inversion-principle-dip)
- [GRASP](#grasp)
    - [Information expert](#information-expert)
    - [Creator](#creator)
    - [Controller](#controller)
    - [Low coupling](#low-coupling)
    - [High cohesion](#high-cohesion)
    - [Polymorphism](#polymorphism)
    - [Pure fabrication](#pure-fabrication)
    - [Indirection](#indirection)
    - [Protected variations](#protected-variations)
- [DRY](#dry)
- [KISS](#kiss)
- [YAGNI](#yagni)
- [Law of Demeter](#law-of-demeter)
- [Coupling](#coupling)
- [Инварианты](#инварианты)
- [Рефакторинг](#рефакторинг)
- [Типизация в языках программирования](#типизация-в-языках-программирования)
- [Что почитать/посмотреть](#что-почитатьпосмотреть)

## Принципы ООП

### Обмен сообщениями

Взаимодействие между объектами осуществляется посредством отправки сообщений друг другу. Обмен сообщениями приводит к чрезвычайно позднему связыванию (extreme late binding).

### Инкапсуляция

Связывание данных и поведения в единый механизм. Обеспечивает сокрытие данных (приватные свойства + публичные методы). 

### Полиморфизм

Один интерфейс, множество реализаций. Полиморфизм - это способность функции обрабатывать данные разных типов. Виды полиморфизма:

- полиморфизм подтипов (наследование и апкаст)
- параметрический (дженерики)
- специальный, "ad hoc" (перегрузка методов)

### Наследование

Наследование - механизм, позволяющий создание нового объекта на основе уже существующего.

> Не самый важный из принципов. Зачастую может быть заменен композицией. Из минусов - увеличивает coupling.

### Абстракция

Абстракция - набор значимых характеристик объекта. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

> Тоже не самый важный принцип, т.к. слишком общий и очевидный.

## SOLID

Основной смысл - стремление уменьшить эффект каскадного изменения модулей.

### Single responsibility principle (SRP)

На каждый класс должна быть возложена одна единственная обязанность. Классы должны иметь одну и только одну причину для изменений.

### Open-closed principle (OCP)

Классы должны быть открыты для расширения, но закрыты для изменения. Т.е. классы могут менять свое поведение без изменения их исходного кода.

### Liskov substitution principle (LSP)

Классы, которые используют базовый класс, должны иметь возможность использовать наследников базового класса не зная об этом.

### Interface segregation principle (ISP)

Клиенты не должны зависеть от методов, которые они не используют. Слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

### Dependency inversion principle (DIP)

Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

## GRASP

GRASP - тот же SOLID, но другими словами. Если плохо воспринимается SOLID - стоит посмотреть GRASP.

### Information expert

Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения - **информационному эксперту**.

> Например, имеется **Customer**, который имеет ссылки на все свои **Order**. Очевидно, **Customer** может взять на себя ответственность за рассчет общей стоимости всех **Order**, т.к. он владеет всей необходимой для этого действия информацией.

### Creator

Класс должен создавать экземпляры тех классов, которые он может содержать или агрегировать, записывать, использовать и инициализировать, имея нужные данные.

```php
final class Customer
{
    private array $orders;
    
    public function addOrder(array $products): void
    {
        $order = new Order($products); // Customer является создателем для Order.
        
        $ordersThatOrderedToday = array_filter($this->orders, static function (Order $order) => {
            return $order->isOrderedToday();
        });
        
        if (count($ordersThatOrderedToday) > 1) {
            throw new \DomainException('Нельзя создать более одного заказа в день.');
        }
        
        $this->orders[] = $order;
    }
}
```
### Controller

Отвечает за операции, запросы на которые приходят от пользователя. Не выполняет работу самостоятельно, а делегирует компетентным исполнителям.

Не является контроллером из MVC! Контроллеры в GRASP - это объекты управляющие обработкой бизнес-транзакций (Use case, Interactor, Handler и т.п.).

### Low coupling

Слабая связь - распределение ответственностей и данных, обеспечивающее взаимную независимость элементов. Элемент со "слабой" связью:

- имеет слабую зависимость от других элементов системы
- не зависит от внешних изменений (изменение одного элемента оказывает слабое влияние на другие элементы)
- прост для повторного использования

> См. также "shotgun surgery".

### High cohesion

По сути это single responsibility принцип. Это мера того, насколько сильно связаны все обязанности элемента. Другими словами, в какой степени части внутри элемента принадлежат друг другу.

### Polymorphism

См. [полиморфизм](#полиморфизм).

### Pure fabrication

Существует понятие модели программирования по предметной области, согласно которой, каждой сущности из предметной области соответствует один или более классов программной среды. При этом, обязанности взаимодействия сущностей, как правило накладываются на них самих. Такой подход имеет очевидный недостаток - высокая связность модулей системы. Шаблон чистая выдумка позволяет решить данную проблему, путем введения в программную среду дополнительного класса (не отражающего реальной сущности из предметной области) и наделение его требуемыми обязанностями.

Например, обязанности по сохранению информации о клиентах судоходной компании можно назначить выдуманному классу **ClientsSaver**.

Применение шаблона чистая выдумка позволяет дизайну системы соответствовать принципам низкой связности и высокого зацепления.

Иногда действительно сложно понять, на что следует возложить ответственность. Вот почему в DDD существует концепция доменного сервиса. Доменные сервисы содержат логику, не связанную с одной конкретной сущностью.

### Indirection

> Нужно наполнить.

### Protected variations

> Нужно наполнить.

## DRY

Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы.

Нарушения принципа DRY называют WET - "write everything twice" (пиши всё по два раза) или "we enjoy typing" (нам нравится печатать).

## KISS

Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

## YAGNI

Отказ от добавления функциональности, в которой нет непосредственной надобности.

## Law of Demeter

Говоря упрощённо, каждый программный модуль:

- должен обладать ограниченным знанием о других модулях - знать о модулях, которые имеют непосредственное отношение к этому модулю
- должен взаимодействовать только с известными ему модулями "друзьями", не взаимодействовать с "незнакомцами"
- обращаться только к непосредственным "друзьям"

## Coupling

"Плохие" виды связанности:

- content - ?
- global - глобальные переменные, база данных
- condition - ?
- temporal - завязанность на времени, например, методы нужно вызывать в определенной последовательности

Эти получше:

- data - ?
- message - когда у методов нет аргументов, т.е. объекты обмениваются сообщениями

От data и message связанностей не получится избавиться. Нужно стараться переходить от "плохих" видов связанности к лучшим.

## Инварианты

В коде они обычно выглядят так:

- транзакции - какие то изменения, которые либо прошли целиком, либо целиком откатились
- валидация перед сохранением - которая либо дала сохранить изменения, либо упала с ошибкой о некорректном состоянии
- в целом, любое исключение может оказаться следствием поддержки инварианта - обеспечение целостности
- функциональные программы часто инвариантны, т.к. не меняют состояние исходного объекта
- приватные поля объекта, которые может менять только сам объект, плюс каждый публичный метод меняет их из рабочего и согласованного состояния в рабочее и согласованное состояние

## Рефакторинг

При анализе большинства программ обнаруживается, что большая часть времени расходуется небольшой частью кода. Если в равной мере оптимизировать весь код, то окажется, что 90% оптимизации произведено впустую.

Вместо реализации гибких решений следует задаться вопросом - "насколько сложно будет с помощью рефакторинга преобразовать обычное решение в гибкое?". Если, как чаще всего случается, ответ будет "весьма несложно", то надо просто реализовать обычное решение.

## Типизация в языках программирования

Существует два вида типизации - **статическая** (типы проверяются на этапе компиляции) и **динамическая** (типы проверяются в рантайме).

Типизация может быть **сильной** (строгой) и **слабой**. В разных языках программирования уровень строгости различается, например, в JavaScript слабая типизация, в PHP средняя, в Python ближе к сильной.

**Утиная типизация** - определение факта реализации определённого интерфейса объектом без явного указания или наследования этого интерфейса, а просто по реализации полного набора его методов.

## Что почитать/посмотреть

- [Функторы, аппликативные функторы и монады в картинках](https://habr.com/ru/post/183150)
