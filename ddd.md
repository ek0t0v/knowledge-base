# DDD

- [DDD это...](#ddd-это)
- [Ключевые понятия](#ключевые-понятия)
    - [Ограниченный контекст (bounded context)](#ограниченный-контекст-bounded-context)
    - [Карта контекстов (context map)](#карта-контекстов-context-map)
    - [Сущность (entity)](#сущность-entity)
    - [Объект-значение (value object)](#объект-значение-value-object)
    - [Агрегат (aggregate)](#агрегат-aggregate)
    - [Сервис (service)](#сервис-service)
    - [Фабрика (factory)](#фабрика-factory)
    - [Хранилище (repository)](#хранилище-repository)
- [Виды доменов](#виды-доменов)
    - [Core domain](#core-domain)
    - [Supporting subdomain](#supporting-subdomain)
    - [Generic subdomain](#generic-subdomain)
- [Ассоциации между моделями](#ассоциации-между-моделями)
- [Что почитать/посмотреть](#что-почитатьпосмотреть)

## DDD это...

- общий язык
- находить экспертов в предметной области и общаться с ними на общем языке
- находить и выделять ограниченные контексты
- моделировать *поведение*, а не *данные*
- не пытаться моделировать *правильные* модели (их не существует), модель должна быть *полезной* для решения определенной задачи
- не давать деталям инфраструктуры влиять на модели предметной области (model first)
- учитывать, что модель предметной области развивается и развиваться вслед за ней
- понимать, что логика бывает разной - не всякая логика достойна считаться доменной
- to be continued...

## Ключевые понятия

### Ограниченный контекст (bounded context)

Контекстность - один из фундаментальных принципов предметно-ориентированного проектирования. Создание единых универсальных моделей - нетривиальная задача, в особенности когда предметная область на самом деле большая и сложная. С большой моделью сложнее решать задачи, такая модель неповоротлива, противоречива, тяжела для понимания. Идея в том, что вместо одной большой модели можно иметь несколько моделей поменьше, каждая из которых будет иметь смысл и будет максимально полезна в определенном ограниченном контексте. Ограниченный контекст задает диапазон применимости каждой модели.

![bounded-context-1](static/bounded-context-1.png)
> Здесь нет единого Customer, который обладает всем поведением и всеми данными, что могло бы позволить использовать его "глобально". Вместо этого Customer представлен в двух разных контекстах. Например, в sales-контексте Customer мог бы иметь платежные данные и соответствующее поведение, а в support-контексте - иметь поведение, необходимое для создания заявок на возврат товара.

### Карта контекстов (context map)

Карта контекстов отображает взаимодействие ограниченных контекстов.

### Сущность (entity)

Сущность - логически целостный объект, определяемый совокупностью индивидуальных черт, главное свойство сущности - индивидуальность. Сущность должна иметь идентификатор.

Рассмотрим транзакции в банковских операциях. Два депозита на одну и ту же сумму в один и тот же день являются различными транзакциями, у них есть индивидуальность и поэтому они - сущности.

Бывают случаи, когда какая-то вещь при одних условиях является сущностью, при других же - нет.

### Объект-значение (value object)

Объектом-значением называется объект, который представляет описательный аспект предметной области и не имеет индивидуального существования, идентичности. Такие объекты создаются в программе для представления тех элементов проекта, о которых достаточно знать только, что они собой представляют, но не кем именно они являются.

### Агрегат (aggregate)

Совокупность взаимосвязанных объектов (сущностей и объектов-значений), которые мы воспринимаем как единое целое с точки зрения изменения данных, называется агрегатом.

У каждого агрегата есть корневой объект (aggregation root, AR) - это одна из сущностей, которая является "точкой доступа" к агрегату. Все действия над агрегатом производятся исключительно через корневой объект.

Корневой объект - единственный член агрегата, на который могут ссылаться внешние объекты, в то время как объекты, заключенные внутри границы, могут ссылаться друг на друга как угодно. Корневой объект агрегата имеет глобальную идентичность, остальные члены агерегата - локальную идентичность (эти объекты уникальны только в границах агрегата).

Агрегат несет полную ответственность за проверку инвариантов. Как только вносится изменение в любой объект внутри границ агрегата, следует сразу удовлетворить все инварианты этого агрегата.

У каждого агрегата есть граница, которая определяет, что находится внутри агрегата.

Из базы данных можно получать только корневые объекты агрегатов, все остальные объекты разрешается извлекать только по цепочке связей.

Операция удаления должна одновременно ликвидировать все, что находится в границах агрегата.

### Сервис (service)

Сервис используется в тех случаях, когда отдельно взятый агрегат не может выполнить операцию, т.к. это выходит за его рамки. Например, проверка уникальности адреса электронной почты (не очень хороший пример, но все же), которую можно осуществить только находясь на уровне нескольких агрегатов.

Название сервиса - глагол, а не существительное.

Сервис не инкапсулирует никакого состояния и не имеет побочных эффектов.

Сервисы применимы и на инфраструктурном уровне, и на уровне домена, но нужно четко обозначать их различие.

> Доменный сервис - это пример применения шаблона pure fabrication из GRASP.

### Фабрика (factory)

Если создание объекта или целого агрегата представляет большую сложность или открывает постороннему глазу слишком много внутренней структуры, то нужную инкапсуляцию обеспечивают фабрики.

Любая хорошая фабрика должна отвечать двум фундаментальным требованиям:

- каждый метод создания объекта должен быть един и неделим, он должен гарантировать соблюдение всех инвариантов создаваемого объекта или агрегата, фабрика должна уметь создавать только объект целиком в корректном состоянии
- абстрагировать фабрику следует к желаемому типу, а не к конкретному классу

### Хранилище (repository)

Наличие хранилища снимает с клиента огромную тяжесть - теперь он может общаться с простым, скрывающим технические подробности интерфейсом, и запрашивать нужную ему информацию в терминах модели. Клиент должен опираться на модель, а все операции хранения и обработки данных объектов должны быть переданы хранилищам.

Оставьте контроль транзакций клиенту. Хотя именно хранилище помещает данные в базу и извлекает их оттуда, оно, как правило, не должно контролировать их завершение (т.е. выполнять фиксацию транзакции). Конечно, есть искушение, например, зафиксировать транзакцию после сохранения данных, но у клиента наверняка есть собственный контекст для корректной инициализации и завершения отдельных рабочих операций. Контроль транзакций со стороны клиента значительно облегчается, если хранилище в это дело не вмешивается.

В проектах с большим количеством запросов можно попытаться построить не просто хранилище, а целую архитектурную среду, ассоциированную с ним, в которой можно было бы составлять более гибкие запросы. Одно из особенно удачных решений для обобщения хранилищ путем создания архитектурной среды состоит в том, чтобы строить запросы на основе спецификаций. Спецификация позволяет клиенту описывать, что именно ему нужно, и при этом не беспокоиться, как именно это делается. В процессе этого создается объект, который фактически и осуществляет нужный выбор.

## Виды доменов

### Core domain

Core domain - the most important subdomain, which is essential for the business. Without it the business would fail. If you ever need to pick the first solution to implement - start with the core domain.

### Supporting subdomain

Supporting subdomain - subdomain, which is less valuable for business than Core domain. Without it business may be can even survive for some time. But it still is quite important (supports core domain), it also is specific for the domain and has to be developed. In this case, for some reason, we can't buy an existing software or component to solve the problem.

### Generic subdomain

Generic subdomain - subdomain which is less valuable for business than Core domain. It also is generic enough to allow buying it off the shelf (unlike supporting domain).

## Ассоциации между моделями

- простые связи лучше сложных, по возможности стоит избегать связи многие-ко-многим 
- у некоторых связей одно из направлений может быть более значимым, т.е. в каких-то случаях можно избежать двунаправленных связей, используя однонаправленные 
- самое сильное упрощение - вообще избавиться от связи, если она несущественна для работы или фундаментального понимания объектов модели

## Что почитать/посмотреть

- [All our aggregates are wrong](https://www.youtube.com/watch?v=hev65ozmYPI)
- [Don't create aggregate roots](https://udidahan.com/2009/06/29/dont-create-aggregate-roots/comment-page-2)
- [Context mapping](https://github.com/ddd-crew/context-mapping)
- [Bounded context](https://martinfowler.com/bliki/BoundedContext.html)
- [Domain model purity vs. domain model completeness](https://enterprisecraftsmanship.com/posts/domain-model-purity-completeness)
- [The art of discovering bounded contexts](https://www.youtube.com/watch?v=ez9GWESKG4I)
- [DDD needn't be hard](https://www.thoughtworks.com/insights/blog/domain-driven-design-neednt-be-hard-heres-how-start)
- [Domain events salvation](https://udidahan.com/2009/06/14/domain-events-salvation)
- [What is domain logic](https://enterprisecraftsmanship.com/posts/what-is-domain-logic)
- [Domain model isolation](https://enterprisecraftsmanship.com/posts/domain-model-isolation)
- [Immutable architecture](https://enterprisecraftsmanship.com/posts/immutable-architecture)
- [Repositories](https://softwareengineering.stackexchange.com/a/434221)
